# 失败语义（Failure Semantics）

本文档定义了 **mariadb-ha-3node** 在各种故障场景下的**唯一、明确、可预测的系统行为**。

这是本项目的**核心文档**。  
所有实现细节（ProxySQL、Orchestrator、脚本）都必须服从本文档中定义的语义，
而不是反过来“用实现解释行为”。

---

## 1. 设计前提与约束

本项目的失败语义基于以下**不可动摇的前提**：

1. 系统运行在 **多地环境**，网络不可靠，可能发生分区
2. 使用 **MariaDB 主从复制**，而非原生共识协议（如 Raft）
3. 启用 **半同步复制（Semi-Sync）**
4. 写入必须满足：**至少 1 台 Replica 完成 ACK**
5. **不允许静默数据不一致**
6. 在一致性与可用性冲突时，**优先保证一致性**

换句话说：

> **本系统允许“不可用”，但不允许“写错”。**

---

## 2. 节点与角色定义

系统包含三个数据库节点：

| 节点 | 角色 | 说明 |
|-----|------|------|
| Node-1 | Primary | 唯一可写主节点 |
| Node-2 | Replica | 从节点 |
| Node-3 | Replica（中立） | 从节点 + Quorum 见证 |

系统中还包含两个逻辑组件：

- **ProxySQL**：负责读写路由，不做主判定
- **Orchestrator**：负责拓扑感知、故障切换与 fencing

---

## 3. Quorum（多数派）定义

### 3.1 写入 Quorum

- Replica 总数：2
- 写入所需 ACK 数：**≥ 1**

即：

> **任意时刻，只要 Primary 能与至少一个 Replica 完成半同步确认，写入才被允许。**

---

### 3.2 决策 Quorum

在发生故障切换时：

- 至少需要 **2 个数据库节点彼此可见**
- Orchestrator 只能在 **满足多数派的前提下** 执行主切换

---

## 4. 核心失败语义矩阵

下表定义了系统在各种关键故障场景下的**唯一合法行为**。

### 4.1 故障场景矩阵

| 场景 | 是否可写 | 是否可读 | 行为说明 |
|----|---------|---------|---------|
| 所有节点健康 | 是 | 是 | 正常运行 |
| Primary 宕机，2 个 Replica 存活 | 是 | 是 | Orchestrator 选主并切换 |
| Primary 宕机，仅 1 个 Replica 存活 | 否 | 是 | 无法形成 Quorum，拒绝写 |
| 任意 1 个 Replica 宕机 | 是 | 是 | 仍可满足 ACK ≥ 1 |
| 两个 Replica 同时不可达 | 否 | 是 | 无法满足写入 Quorum |
| Primary 与 Replica 发生网络分区 | 否 | 是 | 防止孤岛主写入 |
| 任一机房整体不可达 | 视情况 | 是 | 取决于是否仍满足多数派 |
| Quorum 不满足（任何原因） | 否 | 可选 | 明确拒绝写入 |

---

## 5. 关键设计决策解释

### 5.1 为什么 Quorum 不满足时必须拒绝写？

因为在以下情况下：

- Primary 无法确认是否仍是“唯一真相”
- Replica 可能已经形成另一侧多数派
- 继续写入将导致**不可修复的数据分叉**

拒绝写入是**唯一正确行为**。

---

### 5.2 为什么允许“只读可用”？

在一致性系统中：

- **读旧数据是可接受的**
- **写错数据是不可接受的**

因此，在写被拒绝时：
- 允许系统继续提供只读服务
- 是否启用只读，由上层业务自行决定

---

### 5.3 为什么不允许自动降级为异步复制？

自动降级意味着：

- 写入语义在故障时被“偷偷改变”
- 应用无法感知一致性边界
- 违反“显式失败语义”的设计原则

因此：

> **本项目明确禁止任何形式的隐式一致性降级。**

---

### 5.4 为什么不让数据库线程无限阻塞等待？

无限阻塞会导致：

- 连接耗尽
- 锁堆积
- 不可预测的雪崩行为

正确做法是：

- 在系统层面快速拒绝写请求
- 将“等待 / 排队 / 重试”的语义交给上游系统

---

## 6. Split-Brain（脑裂）防护语义

在任何可能导致双主的场景下：

- 系统必须选择 **拒绝写入**
- 或通过 fencing 强制隔离旧主

**不存在**：
- “两个主都可短暂写入”
- “事后人工修复”的合法路径

---

## 7. 失败语义的完备性声明

本失败语义矩阵满足以下条件：

1. **封闭性**  
   任意单点或组合故障，均可归入上述场景之一

2. **确定性**  
   在相同故障条件下，不存在多种合法行为

3. **可推理性**  
   行为可由 Quorum 与一致性原则直接推导

---

## 8. 非目标（明确声明）

以下行为**不在本项目目标范围内**：

- 追求 100% 可用性
- 在网络分区下继续写入
- 自动修复已发生的数据分叉
- 依赖人工判断“哪个主更正确”

---

## 9. 总结

本项目的失败语义可以概括为一句话：

> **在不确定的世界中，选择确定的失败方式。**

这不是保守，而是对数据系统应有边界的尊重。
